<!DOCTYPE html>
<html>
<head>
	<title>webGL Camera 照相机</title>
	<link rel="stylesheet" type="text/css" href="../../css/main.css">
	<script src="../../js/three/three.js"></script>
	<meta charset="utf-8">
</head>
<body>
<div class="home"><a href="../../index.html">首页</a></div>

<div class="aTitle">照相机分类</div>
<div class="aPane">
	<div class="aCode">
		<pre class="note">
1. 正交投影照相机
2. 透视投影照相机
		</pre>
	</div>
</div>

<div class="aTitle">正交投影照相机</div>
<div class="aPane">
	<div class="aCode">
		<pre class="note">
<b>构造函数：</b>
THREE.OrthographicCamera(left, right, top, bottom, near, far)
* 这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置
* 这六个面围成一个长方体，我们称其为视景体（Frustum）
* 只有在视景体内部的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉	

<b>页面：</b>
&lt;div class="aShow note" id="app1"&gt;&lt;/div&gt;

<b>脚本：</b>
// HTML中无canvas标签，自动创建
var renderer = new THREE.WebGLRenderer();
renderer.setSize(200, 150);
var parentEle = document.getElementById('app1')
parentEle.appendChild(renderer.domElement);

// 将背景色（用于清除画面的颜色)
renderer.setClearColor(0x000000);
// 场景
var scene = new THREE.Scene();
// 正交投影摄像机
<mark>var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10);</mark>
camera.position.set(0, 0, 5);
// 照相机默认沿z轴负方向观察，通过设置lookAt的位置可以改变观察的方向
camera.lookAt(new THREE.Vector3(0, 0, 0));
scene.add(camera);

// 正方体
var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true
    })
);
scene.add(cube);

// 进行渲染
renderer.render(scene, camera);	
		</pre>
	</div>
	<div class="aShow note" id="app1">
	</div>
</div>
<script type="text/javascript">
init();
function init () {
	// HTML中无canvas标签，自动创建
	var renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(200, 150);
	var parentEle = document.getElementById('app1')
	parentEle.appendChild(renderer.domElement);

	// 将背景色（用于清除画面的颜色)
	renderer.setClearColor(0x000000);
	// 场景
	var scene = new THREE.Scene();
	// 正交投影摄像机
	var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10);
	camera.position.set(0, 0, 5);
	// 照相机默认沿z轴负方向观察，通过设置lookAt的位置可以改变观察的方向
	camera.lookAt(new THREE.Vector3(0, 0, 0));
	scene.add(camera);

	// 正方体
	var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
	    new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        })
	);
	scene.add(cube);

	// 进行渲染
	renderer.render(scene, camera);
}
</script>

<div class="aTitle">透视投影照相机</div>
<div class="aPane">
	<div class="aCode">
		<pre class="note">
<b>构造函数：</b>
THREE.PerspectiveCamera(fov, aspect, near, far)
* fov是视景体竖直方向上的张角
* aspect等于width / height，是照相机水平方向和竖直方向长度的比值，
  通常设为Canvas的横纵比例	

<b>页面：</b>
&lt;div class="aShow note" id="app2"&gt;&lt;/div&gt;

<b>脚本：</b>
// HTML中无canvas标签，自动创建
var renderer = new THREE.WebGLRenderer();
renderer.setSize(200, 150);
var parentEle = document.getElementById('app2')
parentEle.appendChild(renderer.domElement);

// 将背景色（用于清除画面的颜色)
renderer.setClearColor(0x000000);
// 场景
var scene = new THREE.Scene();
// 透视投影摄像机
<mark>var camera = new THREE.PerspectiveCamera(45, 4/3, 1, 10);</mark>
camera.position.set(2, 2, 3);
// 照相机默认沿z轴负方向观察，通过设置lookAt的位置可以改变观察的方向
camera.lookAt(new THREE.Vector3(0, 0, 0));
scene.add(camera);

// 正方体
var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true
    })
);
scene.add(cube);

// 进行渲染
renderer.render(scene, camera);	
		</pre>
	</div>
	<div class="aShow note" id="app2">
	</div>
</div>
<script type="text/javascript">
init2();
function init2 () {
	// HTML中无canvas标签，自动创建
	var renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize(200, 150);
	var parentEle = document.getElementById('app2')
	parentEle.appendChild(renderer.domElement);

	// 将背景色（用于清除画面的颜色)
	renderer.setClearColor(0x000000);
	// 场景
	var scene = new THREE.Scene();
	// 透视投影摄像机
	var camera = new THREE.PerspectiveCamera(45, 4/3, 1, 10);
	camera.position.set(2, 2, 3);
	// 照相机默认沿z轴负方向观察，通过设置lookAt的位置可以改变观察的方向
	camera.lookAt(new THREE.Vector3(0, 0, 0));
	scene.add(camera);

	// 正方体
	var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
	    new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        })
	);
	scene.add(cube);

	// 进行渲染
	renderer.render(scene, camera);
}
</script>

</body>
</html>